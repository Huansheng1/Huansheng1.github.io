# 网络通信
## 讲一讲HTTP请求三次握手
> [关于三次握手与四次挥手面试官想考我们什么](https://juejin.cn/post/6844903834708344840?searchId=2024021719035905F7961FC9ED3FF58FB9)

`三次握手`和`四次挥手`是与 **TCP（传输控制协议）** 连接建立和关闭相关的概念。

在连接建立时，客户端和服务器之间进行三次握手以确保双方都准备好进行通信。

> 三次握手：
* 握手的目的是 确认双方的通信能力和同步初始序列号（ISN）。

> 三次握手的步骤如下：
1. 第一次握手：客户端向服务器发送一个同步信号（SYN），并附带自己的初始序列号（ISN）。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
2. 第二次握手：服务器收到客户端的同步信号，并记录客户端的ISN，同时生成自己的ISN；然后 向客户端发送一个同步和确认信号（SYN+ACK），其中包含服务器的ISN。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
3. 第三次握手：客户端收到服务器的同步和确认信号，并记录服务器的ISN；给服务器发送一个确认信号（ACK）。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

> 为什么是三次握手而不是两次或四次呢？这是因为：

* 三次握手足以确认双方的通信能力和初始序列号同步。
* 如果只有两次握手，服务端只能一直接收请求，然后返回请求信息，但不知道客户端是否请求成功。并且 假设客户端发送的 SYN 信号在网络中阻塞，然后恢复时已经失效，再次到达服务器。如果只有两次握手，客户端无法判断连接是否为历史连接，可能会建立冗余的无效链接。
* 四次握手会增加额外的通信开销，而且不会提供更多的可靠性保证。
* 在第三次握手完成后，双方已经确认了对方的准备状态，没有必要再增加额外的确认步骤

在连接断开时，客户端和服务器之间进行四次握手以安全地关闭连接。
> 四次握/挥手：

* 握手的目的是 确认双方都已经完成数据传输，可以安全地关闭连接。

> 四次握手的步骤如下：
1. 第一次挥手：客户端向服务器发送一个结束信号（FIN），表示不再发送数据，报文中会指定一个序列号（ISN）。此时客户端处于FIN_WAIT状态。
2. 第二次挥手：服务端收到 结束信号（FIN） 之后，会发送 确认信号（ACK） 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。
3. 第三次挥手：服务器向客户端发送一个结束信号（FIN），并在报文中携带 序列号（ISN），表示服务器不再发送数据。此时服务端处于 LAST_ACK 的状态。
4. 第四次挥手：客户端收到 结束信号（FIN） 之后，给服务器发送一个 确认信号（ACK） 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态

四次握手确保了双方都知道对方已经完成数据传输，可以安全地关闭连接。

### 注意
1. 为了保证安全，ISN 是动态生成的。
2. 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
3. 关于`SYN-ACK 重传次数`的问题：服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ....
4. 三次握手过程中可以携带数据
5. 为什么客户端发送 确认信号（ACK） 之后不直接关闭，而是要等一阵子才关闭。原因是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。
6.  TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。

## 说一说跨域？
答：跨域问题源于浏览器出于安全考虑，为了防止跨域攻击而设置的同源策略限制，该策略限制了从一个源加载的网页脚本与另一个源的交互。同源是指：协议、域名、端口号相同。如果不同的话，就是跨域。
> 为了解决跨域问题，我们通常有以下几种做法：
* 使用CORS（跨域资源共享）来处理，也就是 服务器在返回请求头中添加Access-Control-Allow-Origin: * 或者 指定允许的域名 实现；CORS是W3C标准，全称是跨域资源共享（Cross-origin resource sharing）。CORS允许浏览器向跨源服务器，发出XMLHttpRequest请求。服务器收到请求以后，在Access-Control-Allow-Origin响应头中指定允许跨域的域名，就可以在客户端进行XMLHttpRequest请求。
* jsonp - 利用 <script> 标签不受同源策略限制，通过动态创建 src 属性指向服务端提供的接口，并带上回调函数名，服务端返回调用这个回调函数并携带数据的JS代码。
* 配置代理 - 在本地配置代理，将跨域请求代理到同源服务器。
* WebSocket - WebSocket协议本身支持跨域，通过握手过程中服务器发送正确的Access-Control-Allow-Origin来实现跨域通信。
* POSTMessage - 比如iframe和父页面间的跨域通信，通过window.postMessage()方法发送消息，同时监听message事件接收消息。
* Image - 利用图片请求可以跨域的特点，通过创建Image对象并向其src属性设置跨域URL进行GET方式的数据传输。不适用于POST或复杂操作。

## JWT 的优点

![](https://cdnjson.com/images/2024/04/23/image79eaf7c00786fb0a.png)

## 前端缓存的了解？
> [百度一面：细节不容忽视，直戳难点（含面试题）](https://juejin.cn/post/7340834858275602484?searchId=20240423094815A403AB7F10D3F38E8271#heading-27)

## 讲讲WebSocket协议，包括性能问题、解决方案、连接数量限制等

## 浏览器访问URL的过程？
> [😎😎（超详细）从输入url到渲染页面发生了什么，你真的知道吗](https://juejin.cn/post/7320224895228133388)

## 常见的状态码有什么含义？
> [http状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)

> HTTP状态码是服务器在响应客户端请求时返回的一个三位数字。这些状态码被分为五类11：

* 信息响应 (100 – 199)：这类状态码表示请求已被接收，需要客户端继续执行操作
* 成功响应 (200 – 299)：这类状态码表示请求已成功被服务器接收、理解、并接受
* 重定向 (300 – 399)：这类状态码表示需要进一步操作以完成请求
* 客户端错误 (400 – 499)：这类状态码表示请求包含语法错误或无法完成请求
* 服务器错误 (500 – 599)：这类状态码表示服务器在处理请求的过程中发生了错误

> 以下是一些常见的HTTP状态码及其含义：

* 200 OK：请求成功。具体的含义取决于所使用的HTTP方法
* 201 Created：请求成功，并且服务器创建了新的资源
* 204 No Content：服务器成功处理了请求，但没有返回任何内容
* 301 Moved Permanently：被请求的资源已永久移动到新位置
* 400 Bad Request：服务器无法理解请求的格式
* 401 Unauthorized：请求需要用户验证
* 403 Forbidden：服务器理解请求，但是拒绝执行
* 404 Not Found：服务器无法找到请求的资源
* 500 Internal Server Error：服务器内部错误，无法完成请求

## 如何对网页访问速度进行优化？
> [如何让iframe加载第三方页面速度变快](https://juejin.cn/post/7341329626357235749?searchId=20240424173657D99FFB1594D9B5987213)

## 浏览器输入url，到看到页面会发生什么

## 除了http还有哪些通信协议

## websocket通信过程是怎么样的

## 前端安全方面有哪些攻击方式；该怎么处理

## node有哪些框架可以处理脚本攻击（或者是库）

