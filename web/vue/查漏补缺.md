# Vue知识点
## v-if 和 v-show 有什么区别？我们应该在什么情况下使用 v-if，什么情况下使用 v-show 呢？

Vue 官方中对 v-if 和 v-show 的使用场景区分是： `当需要频繁显示和隐藏的时候，那么需要使用 v-show 否则需要使用 v-if`。

但是在实际的开发中我们是 很难分辨某个元素或者组件是否是频繁切换的。

所以说，在实际开发中，判断 v-if 和 v-show 的使用需要根据它们的特性来进行判断。

因为 `v-show 不会导致组件被销毁和渲染，但是 v-if 会导致组件被销毁和重新渲染。`

也就是说：当使用 v-show 时，虽然用户看不到组件，但是当前组件的生命周期都已经执行了。如果在 created 中存在接口的调用，则【接口已经调用完成】。同时，当组件隐藏时，组件并不会销毁。相反：如果是 v-if 的每次点击时都会重新渲染组件，重新执行生命周期，隐藏则销毁组件。

所以说，判断 v-if 和 v-show 的使用条件应该是：`当组件需要在指定时机创建，在指定时机销毁时，需要使用 v-if。而 当组件仅需要创建一次时，则可以使用 v-show。`

## Vue 的生命周期？
> Vue.js 组件的生命周期可以分为三个阶段：创建阶段、更新阶段和销毁阶段。在每个阶段，Vue.js 提供了一系列钩子函数，允许开发者在组件的不同生命周期中执行相关逻辑。

![](https://cdnjson.com/images/2024/04/23/image54f3c0a0051cee15.png)

## Vue2和Vue3的区别/Vue2升级到Vue3，你觉得有哪些变化？
> [盘点 Vue3 与 Vue2 的区别](https://juejin.cn/post/7067413380922867725?searchId=202404232121496D693975D868892C4BC1#heading-0)

1. Vue3 支持多个根节点
2. 破坏性变更，废弃和调整了不少api，比如 弃用Events API、mixin Api
3. 新增了 Composition 组合式Api 和 setup，向函数式编程靠拢
4. 更好的支持了 Typescript
5. Vuex 改为了 Pinia

## MVVM 架构是什么意思？
> [Vue MVVM理解及原理实现](https://juejin.cn/post/6844903929298288647?searchId=202404232353117B2A8BE1A6F2453F08E1)
### MVVM 是什么：
* MVVM 是 Model-View-ViewModel 的缩写。
* 它是一种设计模式，用于构建用户界面。通过将用户界面的开发和业务逻辑的开发分离，MVVM 使得代码更加模块化、可维护性更高，简化了前端开发过程

### MVVM 的核心组成部分：
* 模型（Model）：指的是后端传递的数据。
* 视图（View）：指的是所看到的页面。
* 视图模型（ViewModel）：是 MVVM 模式的核心，它是连接视图和模型的桥梁。
* > 视图模型有两个方向：
* 1. 将 模型 转化成 视图，即将后端传递的数据转化成所看到的页面。这实现方式是通过 数据绑定。
* 2. 将 视图 转化成 模型，即将所看到的页面转化成后端的数据。这实现方式是通过 DOM 事件监听。
* ViewModel层通过双向数据绑定将View层和Model层连接了起来，使得View层和Model层的同步工作完全是自动的。
因此开发者只需关注业务逻辑，无需手动操作DOM。

数据与界面之间的响应和绑定，就称为 数据的双向绑定。


## computed 和 watch 的区别？
1. 计算属性（computed）：
* 计算属性是一种用于快速计算视图中显示属性的方式。
* 它会根据所依赖的数据动态显示新的计算结果，并且这些计算结果会被缓存起来。只有在需要时才会重新计算。
* 适用于一些重复使用数据或复杂且费时的运算。我们可以将这些计算放入 computed 中进行处理，然后会在其中缓存起来，以便下次直接获取。
* 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，通常使用 computed。
2. 侦听属性（watch）：
* 侦听属性用于监听数据的变化并执行相应的操作。
* 当在 data 中的某个数据发生变化时，我们可以使用 watch 来执行一些操作，尤其适用于异步或开销较大的操作。
* watch 不支持缓存，每次监听的值发生变化时都会立即执行回调。
* 监听的函数接收两个参数：最新的值和之前的值。
* 适用于一对多的场景，当一个属性发生变化时，需要执行对应的操作。
3. 区别总结：
> 计算属性：
* 支持缓存，只有依赖数据发生改变时才会重新计算。
* 适用于基于其他属性计算出新值的场景。
* 可以像属性一样直接访问，不需要调用函数。
> 侦听属性：
* 不支持缓存，数据变化时立即执行相应的操作。
* 适用于异步或开销较大的操作。
* 需要定义处理函数，并在函数中执行相应的操作。

## Vue如何确保代码在 Dom 渲染完毕后才执行，用什么方法来实现？
1. 使用 `$nextTick` ，$nextTick 的回调函数会在下一次 DOM 更新循环结束后执行，这样可以避免操作尚未渲染的 DOM 元素的问题。
```js
this.$nextTick(function () {
  // 在这里执行你的代码
});
```
2. setTimeout 来实现，setTimeout 的回调函数会在下一次 DOM 更新循环结束后执行。


## 进阶原理
### 响应式原理
> [Vue双向数据绑定原理(面试必问) ](https://juejin.cn/post/7142532417834713102?searchId=20240228110442C71D3895DEAD4445EB4F)

> Vue响应式数据的原理设计思想是：数据劫持 + 观察者模式。

Vue 通过 Object.defineProperty 方法将对象属性转化为响应式属性，并在访问属性时收集依赖，在属性变化时通知依赖的 Watcher 对象进行更新操作，从而实现数据的响应式更新。

* Vue2里是通过Object.defineProperty来实现的，通过拦截数据的set和get来实现对数据的劫持和监听，当数据变化时，发布消息给订阅者，触发相应的监听回调。
* Vue3里则是通过Proxy来实现的。

进阶问题：
1. 响应式属性 是什么？
答：响应式属性，就是当数据发生变化时，会触发相应的监听回调。

2. 为什么Vue3改用Proxy而不是Object.defineProperty？
详细列出所有的原因：
> 1. Object.defineProperty只能劫持对象的已有的属性，无法监听到对象的新增/删除掉的属性。
> 2. Object.defineProperty无法监听数组的所有变化，比如 push/pop/shift/unshift/splice/sort/reverse等方法它都是通过重写了数组的原型方法来实现的，如果是通过数组的序号来修改数组元素 或者 其他未重写的方法的话，就会无法触发监听回调。

### nextTick 的原理是什么？
> [$nextTick 原理及作用](https://juejin.cn/post/7302710832307617855?searchId=20240424000511D6D4835E068CF23F3A4E)

### Vue 的底层原理有了解吗？

## 参考文章：
* [vue响应式原理](https://juejin.cn/post/7236593298763776060?searchId=20240422132630B8BF24CF52C423186E7F)
* [Vue3响应式方案以及ref reactive的区别](https://blog.csdn.net/Android_boom/article/details/128718469?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7EPaidSort-1-128718469-blog-119421518.235%5Ev43%5Epc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7EPaidSort-1-128718469-blog-119421518.235%5Ev43%5Epc_blog_bottom_relevance_base2&utm_relevant_index=1)
* [秋招解决方案：深入 Vue3 源码，带你彻底打通 Vue3 源码面试](https://juejin.cn/post/7277511894666559488)
