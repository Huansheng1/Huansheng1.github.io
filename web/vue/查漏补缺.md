# Vue知识点
## v-if 和 v-show 有什么区别？我们应该在什么情况下使用 v-if，什么情况下使用 v-show 呢？

Vue 官方中对 v-if 和 v-show 的使用场景区分是： `当需要频繁显示和隐藏的时候，那么需要使用 v-show 否则需要使用 v-if`。

但是在实际的开发中我们是 很难分辨某个元素或者组件是否是频繁切换的。

所以说，在实际开发中，判断 v-if 和 v-show 的使用需要根据它们的特性来进行判断。

因为 `v-show 不会导致组件被销毁和渲染，但是 v-if 会导致组件被销毁和重新渲染。`

也就是说：当使用 v-show 时，虽然用户看不到组件，但是当前组件的生命周期都已经执行了。如果在 created 中存在接口的调用，则【接口已经调用完成】。同时，当组件隐藏时，组件并不会销毁。相反：如果是 v-if 的每次点击时都会重新渲染组件，重新执行生命周期，隐藏则销毁组件。

所以说，判断 v-if 和 v-show 的使用条件应该是：`当组件需要在指定时机创建，在指定时机销毁时，需要使用 v-if。而 当组件仅需要创建一次时，则可以使用 v-show。`

## Vue 的生命周期？
> Vue.js 组件的生命周期可以分为三个阶段：创建阶段、更新阶段和销毁阶段。在每个阶段，Vue.js 提供了一系列钩子函数，允许开发者在组件的不同生命周期中执行相关逻辑。

![](https://cdnjson.com/images/2024/04/23/image54f3c0a0051cee15.png)

## Vue2和Vue3的区别/Vue2升级到Vue3，你觉得有哪些变化？
> [盘点 Vue3 与 Vue2 的区别](https://juejin.cn/post/7067413380922867725?searchId=202404232121496D693975D868892C4BC1#heading-0)

1. Vue3 支持多个根节点
2. 破坏性变更，废弃和调整了不少api，比如 弃用Events API、mixin Api
3. 新增了 Composition 组合式Api 和 setup，向函数式编程靠拢
4. 更好的支持了 Typescript
5. Vuex 改为了 Pinia

## MVVM 架构是什么意思？
> [Vue MVVM理解及原理实现](https://juejin.cn/post/6844903929298288647?searchId=202404232353117B2A8BE1A6F2453F08E1)
### MVVM 是什么：
* MVVM 是 Model-View-ViewModel 的缩写。
* 它是一种设计模式，用于构建用户界面。通过将用户界面的开发和业务逻辑的开发分离，MVVM 使得代码更加模块化、可维护性更高，简化了前端开发过程

### MVVM 的核心组成部分：
* 模型（Model）：指的是后端传递的数据。
* 视图（View）：指的是所看到的页面。
* 视图模型（ViewModel）：是 MVVM 模式的核心，它是连接视图和模型的桥梁。
* > 视图模型有两个方向：
* 1. 将 模型 转化成 视图，即将后端传递的数据转化成所看到的页面。这实现方式是通过 数据绑定。
* 2. 将 视图 转化成 模型，即将所看到的页面转化成后端的数据。这实现方式是通过 DOM 事件监听。
* ViewModel层通过双向数据绑定将View层和Model层连接了起来，使得View层和Model层的同步工作完全是自动的。
因此开发者只需关注业务逻辑，无需手动操作DOM。

数据与界面之间的响应和绑定，就称为 数据的双向绑定。


## computed 和 watch 的区别？
1. 计算属性（computed）：
* 计算属性是一种用于快速计算视图中显示属性的方式。
* 它会根据所依赖的数据动态显示新的计算结果，并且这些计算结果会被缓存起来。只有在需要时才会重新计算。
* 适用于一些重复使用数据或复杂且费时的运算。我们可以将这些计算放入 computed 中进行处理，然后会在其中缓存起来，以便下次直接获取。
* 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，通常使用 computed。
2. 侦听属性（watch）：
* 侦听属性用于监听数据的变化并执行相应的操作。
* 当在 data 中的某个数据发生变化时，我们可以使用 watch 来执行一些操作，尤其适用于异步或开销较大的操作。
* watch 不支持缓存，每次监听的值发生变化时都会立即执行回调。
* 监听的函数接收两个参数：最新的值和之前的值。
* 适用于一对多的场景，当一个属性发生变化时，需要执行对应的操作。
3. 区别总结：
> 计算属性：
* 支持缓存，只有依赖数据发生改变时才会重新计算。
* 适用于基于其他属性计算出新值的场景。
* 可以像属性一样直接访问，不需要调用函数。
> 侦听属性：
* 不支持缓存，数据变化时立即执行相应的操作。
* 适用于异步或开销较大的操作。
* 需要定义处理函数，并在函数中执行相应的操作。

## Vue如何确保代码在 Dom 渲染完毕后才执行，用什么方法来实现？
1. 使用 `$nextTick` ，$nextTick 的回调函数会在下一次 DOM 更新循环结束后执行，这样可以避免操作尚未渲染的 DOM 元素的问题。
```js
this.$nextTick(function () {
  // 在这里执行你的代码
});
```
2. setTimeout 来实现，setTimeout 的回调函数会在下一次 DOM 更新循环结束后执行。


## 进阶原理
### 响应式原理
> [Vue双向数据绑定原理(面试必问) ](https://juejin.cn/post/7142532417834713102?searchId=20240228110442C71D3895DEAD4445EB4F)

> Vue响应式数据的原理设计思想是：数据劫持 + 观察者模式。

Vue 通过 Object.defineProperty 方法将对象属性转化为响应式属性，并在访问属性时收集依赖，在属性变化时通知依赖的 Watcher 对象进行更新操作，从而实现数据的响应式更新。

* Vue2里是通过Object.defineProperty来实现的，通过拦截数据的set和get来实现对数据的劫持和监听，当数据变化时，发布消息给订阅者，触发相应的监听回调。
* Vue3里则是通过Proxy来实现的。

进阶问题：
1. 响应式属性 是什么？
答：响应式属性，就是当数据发生变化时，会触发相应的监听回调。

2. 为什么Vue3改用Proxy而不是Object.defineProperty？
详细列出所有的原因：
> 1. Object.defineProperty只能劫持对象的已有的属性，无法监听到对象的新增/删除掉的属性。
> 2. Object.defineProperty无法监听数组的所有变化，比如 push/pop/shift/unshift/splice/sort/reverse等方法它都是通过重写了数组的原型方法来实现的，如果是通过数组的序号来修改数组元素 或者 其他未重写的方法的话，就会无法触发监听回调。

### nextTick 的原理是什么？
> [$nextTick 原理及作用](https://juejin.cn/post/7302710832307617855?searchId=20240424000511D6D4835E068CF23F3A4E)

> [官方源码](https://raw.githubusercontent.com/vuejs/vue/main/src/core/util/next-tick.ts)

```ts
// Vue2的代码
/* globals MutationObserver */  // 声明全局变量 MutationObserver

import { noop } from 'shared/util'  // 导入 noop 函数，这是一个什么也不做的函数
import { handleError } from './error'  // 导入错误处理函数
import { isIE, isIOS, isNative } from './env'  // 导入环境检测函数

export let isUsingMicroTask = false  // 导出一个标志，表示是否使用微任务

const callbacks: Array<Function> = []  // 定义一个回调函数数组
let pending = false  // 定义一个标志，表示是否有待处理的回调

// 用来 异步执行所有保存下来的回调函数 的函数
let timerFunc

// 为了方便阅读，我把 nextTick 函数提前（源代码是放在最后的）
/**
 * 这个函数的大概逻辑：
 * 1. 先将传入的 回调函数 添加到 callbacks 数组中
 * 2. 如果当前没有待处理的回调，那么调用 timerFunc 来异步执行回调
 * 3. 因为 timerFunc 是异步执行的，这里利用了 事件循环的机制：异步任务的执行优先级是低于同步任务的，这样只有在当前执行栈中执行完所有同步任务之后，才会执行队列中的回调
 * 4. 从而实现了 一个事件循环内的 多个数据变更操作 合并到一次时间里执行
 */
export function nextTick(cb?: (...args: any[]) => any, ctx?: object) {
  let _resolve
  callbacks.push(() => {  // 将回调函数添加到队列中
    if (cb) {
      try {
        cb.call(ctx)  // 如果提供了回调，那么在 nextTick 时执行它
      } catch (e: any) {
        handleError(e, ctx, 'nextTick')  // 如果回调执行出错，那么处理错误
      }
    } else if (_resolve) {
      _resolve(ctx)  // 如果没有提供回调，但提供了 Promise 的 resolve 函数，那么在 nextTick 时调用它
    }
  })
  // 如果当前不在执行 回调函数的话，说明现在可以 开始异步执行新的 回调函数
  if (!pending) {
    pending = true
    timerFunc()  // 如果当前没有待处理的回调，那么调用 timerFunc 来异步执行回调
  }
  // 如果没有传入 回调函数，但环境支持 Promise的话，那么返回一个 Promise 供调用处链式调用
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => { 
      _resolve = resolve
    })
  }
}

function flushCallbacks() {  // 该函数，用于执行所有待处理的回调
  pending = false  // 将待处理标志设为 false
  // slice(start, end)，作用是创建原数组的一个浅拷贝。它从原数组的第一个元素（索引为 0）开始复制，直到数组的最后一个元素，然后返回这个新的数组。这个方法常常用于在不修改原数组的情况下，获取数组的一个副本。
  // 如果 start 和 end 都未定义，slice() 会返回原数组的一个完整拷贝。如果只定义了 start，slice() 会从 start 索引开始，复制到数组的末尾。如果 start 和 end 都定义了，slice() 会从 start 索引开始，复制到 end 索引之前。
  const copies = callbacks.slice(0)  // 复制当前的回调函数数组
  callbacks.length = 0  // 清空回调函数数组
  for (let i = 0; i < copies.length; i++) {  // 遍历复制的回调函数数组
    copies[i]()  // 执行每一个回调函数
  }
  // 为什么要拷贝一份 callbacks

  // 因为考虑到在 nextTick 回调中可能还会调用 nextTick 的情况,
  // 如果在 nextTick 回调中又调用了一次 nextTick，则又会向 callbacks 中添加回调，
  // 而 nextTick 回调中的 nextTick 应该放在下一轮执行，
  // 否则就可能出现一直循环的情况，
  // 所以需要将 callbacks 复制一份出来然后清空，再遍历备份列表执行回调
}

// 根据当前浏览器环境选择是 使用 微任务 还是 宏任务 来执行回调函数列表
// 首选 Promise，因为它是微任务，优先级高于宏任务
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)  // 当 Promise resolve 时，执行所有回调
    if (isIOS) setTimeout(noop)  // 在 iOS 的 UIWebView 中，需要通过 setTimeout 强制刷新微任务队列
  }
  isUsingMicroTask = true
} else if (
  !isIE &&
  typeof MutationObserver !== 'undefined' &&
  (isNative(MutationObserver) ||
    MutationObserver.toString() === '[object MutationObserverConstructor]')
) {
  // 其次选择 MutationObserver，它也是微任务
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // 再次选择 setImmediate，它是宏任务，但优先级高于 setTimeout
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  // 最后选择 setTimeout
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}
```
总结 nextTick 原理：

在 Vue.js 中，当你修改数据（也就是 Vue 实例的 data 属性）时，Vue 会异步更新 DOM 来反映数据的变化。

但如果频繁的数据变化可能会导致大量的 DOM 操作，而 DOM 操作开销是比较大的，为了优化性能，Vue 利用了 事件循环机制 通过采用数组队列+异步任务来缓冲在同一事件循环中发生的所有数据变化。

在 Vue.js 的响应式系统（依赖收集和派发更新的过程）中。当一个数据变化时，会触发与之相关的 watcher，这些 watcher 会被添加到队列中；注意，如果同一个 watcher 被多次触发，Vue.js 会确保它只被添加到队列一次。

而 处理这个异步队列的函数 正是 nextTick 函数。它通过使用微任务（microtask）或宏任务（macrotask）来异步执行队列里的回调函数。

因为 微任务的优先级高于宏任务，所以它的逻辑是 首选 Promise 和 MutationObserver（它们都是微任务），如果环境不支持它们，那么选择 setImmediate 或 setTimeout（它们都是宏任务）。

然后 在这个选定的异步任务 的执行回调函数里 处理实际（已去重的）工作队列，这样就避免不必要的计算和 DOM 操作。

同时以上的方式，即使用户在修改数据之后立即使用 nextTick，它也可以在其回调函数中获取到更新后的 DOM，因为 nextTick 的回调函数是在这个异步任务之后执行。

> 注意，你也许会有疑惑，当前一次的事件循环 tick 里，不是要全部执行完 所有的微任务，才会进行 界面渲染 然后进入下一次 tick 吗？

其实，原因很简单：
1. 我们使用 JavaScript 进行原生DOM操作时，随着 JavaScript 代码执行会同步进行DOM更新；也就是说 Dom的更新是 同步的，这也是 Js单线程的原因。
2. 我们需要明确 UI渲染 和 Dom操作更新是 两回事，前者是 异步的，而后者则是 同步的，不然JS岂不是可能同时出现操作同一个Dom的操作了。
3. 因此，即使是对于兼容的浏览器来说，nextTick相当于是微任务，但$nextTick的回调函数仍然是在当前执行栈的所有同步任务执行完毕后再执行，所以nextTick中会得到 DOM 更新后的结果。（[不过页面渲染始终是在微任务执行之后才进行的，所以$nextTick回调函数执行时页面还没有进行渲染，回调函数执行时在页面上看不到更新后的结果](https://blog.csdn.net/m0_45911911/article/details/124270409)）
### Vue 的底层原理有了解吗？
> [Vue.js设计与实现 霍春阳](https://book.douban.com/subject/35768338/)
> [干了这么多年前端，你搞清楚vue3的底层原理了吗？](https://juejin.cn/post/7356652717392183348?searchId=202404250945020EDC807B469C4BF575BB)

## 参考文章：
* [vue响应式原理](https://juejin.cn/post/7236593298763776060?searchId=20240422132630B8BF24CF52C423186E7F)
* [Vue3响应式方案以及ref reactive的区别](https://blog.csdn.net/Android_boom/article/details/128718469?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7EPaidSort-1-128718469-blog-119421518.235%5Ev43%5Epc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7EPaidSort-1-128718469-blog-119421518.235%5Ev43%5Epc_blog_bottom_relevance_base2&utm_relevant_index=1)
* [秋招解决方案：深入 Vue3 源码，带你彻底打通 Vue3 源码面试](https://juejin.cn/post/7277511894666559488)
* [2023前端面试系列-- Vue 篇](https://juejin.cn/post/7191325434486161467?searchId=202404250945020EDC807B469C4BF575BB)