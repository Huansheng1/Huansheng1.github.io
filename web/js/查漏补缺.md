# JavaScript知识点
# 基础
### 宏任务与微任务怎么区分，用精准而简短的话总结下 事件循环？
> [事件循环](https://juejin.cn/post/7337874795684724772#heading-1)

因为JavaScript 是一门单线程语言，这意味着在同一时间内只能执行一项任务。然而，异步任务往往是耗时的，为了在保持单线程的同时避免异步任务阻塞主线程，于是，JavaScript 引入了事件循环机制。

事件循环是JavaScript执行上下文中的一种机制，用于处理异步操作。它的核心思想是将所有的异步任务放入一个队列中，然后按照队列中的顺序依次执行，直到队列为空为止。主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

而 异步任务分为 宏任务与微任务：  
宏任务：一类相对低优先级的异步任务，由宿主环境（如浏览器或 Node.js）发起，包括 setTimeout、setInterval、网络请求、IO事件、script的整体代码、UI渲染 等。  
微任务：由 JavaScript 引擎自身发起，包括 Promise的then()、catch（）、finally（）方法、MutationObserver 等。  

> 消息队列/任务队列：一个先进先出的队列，它里面存放着各种消息。

> 事件循环：主线程重复从消息队列中取消息、执行的过程。

流程：    
1. 先执行同步代码，所有同步代码都在主线程上执行，形成一个执行栈。
2. 当遇到异步任务时，会将其发起给浏览器提供的辅助线程执行，其执行完毕后，会将注册的回调函数 添加到任务队列中，宏任务放入宏任务队列，微任务放进微任务队列。
3. 当执行栈为空时，事件循环从任务队列中取出一个任务（回调函数），加入到执行栈中执行。
4. 重复上述步骤，直到任务队列为空。

[![](https://cdn.jsdelivr.net/gh/Huansheng1/myimg/PicGo/20200720184008.png)](https://www.processon.com/view/link/5f141dfa6376895d7fb8777c)
### `Es6`中如何解决 回调地狱的问题？（`Promise`是`Es7`的东西）
> 错的，貌似没这个东西

`Promise 是 ES6（ECMAScript 2015）`

async/await是ES2017引入的语法糖，它基于Promise，但提供了更简洁、更直观的异步编程方式。
使用async/await，你可以写出看起来像是同步代码的异步代码，避免了回调函数的嵌套。

### Js 如何实现继承？
*  原型链继承，将子类的prototype指向父类，子类实例化时，会继承父类的属性和方法。
```js
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
function Child() {  
    this.type = 'child';  
}  
  
Child.prototype = new Parent(); 
// 有一个问题，那就是所有的Child实例都会共享父类的属性，如果其中一个Child实例修改了父类属性，那么其他Child实例的父类属性也会被修改。
```
* 借用构造函数（伪造对象或经典继承）
```js
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
function Child() {  
    Parent.call(this);  
    this.type = 'child';  
}  
  
var child1 = new Child();  
// 可以解决原型链继承中所有Child实例共享父类属性的问题，但是方法都在构造函数中定义，每次创建实例都会创建一遍方法，浪费内存。
```
* 组合继承（原型链 + 借用构造函数），使用原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。
```js
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
Parent.prototype.getName = function() {  
    return this.name;  
}  
  
function Child() {  
    Parent.call(this);  
    this.type = 'child';  
}  
  
Child.prototype = new Parent();  
Child.prototype.constructor = Child;  
  
var child1 = new Child();  
// 融合了原型链继承和借用构造函数的优点，是JavaScript中最常用的继承模式。但是，它也调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）。
```
* 拷贝继承，直接复制父类型的属性到子类型中。
```js
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
function Child() {  
    var p = new Parent();  
    for (var i in p) {  
        this[i] = p[i];  
    }  
    this.type = 'child';  
}  
  
var child1 = new Child();  
```
* ES6中的类继承，直接使用 extends 关键字 继承父类。
```js
class Parent {  
    constructor() {  
        this.name = 'parent';  
    }  
    getName() {  
        return this.name;  
    }  
}  
  
class Child extends Parent {  
    constructor() {  
        super();  
        this.type = 'child';  
    }  
}  
  
let child1 = new Child();  
// 既解决了原型链继承的共享问题，又解决了借用构造函数的复用问题，是ES6推荐的继承方式。
```

### Js 的数据类型有哪些？
![](https://cdnjson.com/images/2024/04/23/image85611b9f987c0206.png)
![](https://cdnjson.com/images/2024/04/23/image6636bbbadd40a360.png)

### 想检测一个复杂数据的类型，应该怎么检测？
对象类型 使用 `Object.prototype.toString.call()`
基本数据类型 使用 `typeof`

### 深拷贝 和 浅拷贝的区别？
> 区别在于是否复制了嵌套对象的引用。在JS理，基本数据类型的值直接存储在栈中，而引用数据类型在栈中的值存储的是该对象数据的引用，真实的数据存放在堆内存里。  

> 浅拷贝：

浅拷贝只复制指向某个对象的指针，而不复制对象本身。  
新旧对象仍然共享同一块内存。  
浅拷贝只复制一层，不会递归拷贝嵌套对象的属性。  
常见的浅拷贝方法包括 Object.assign()、Array.prototype.concat() 和 Array.prototype.slice()。  

> 深拷贝：

深拷贝创建一个原始数据结构及其所有嵌套对象的完整副本。  
新对象跟原对象不共享内存，修改新对象不会影响到原对象。  
深拷贝会递归拷贝所有层级的对象属性和数组元素。  
常见的深拷贝方法包括手写递归方法、JSON.parse(JSON.stringify()) 和第三方库如 Lodash 的 _.cloneDeep。  

```js
// 1. 使用 JSON.parse(JSON.stringify(obj)) 实现，但是有一些特殊的类型无法拷贝，如函数、正则、循环递归等。
// 2. 手写递归实现，递归拷贝所有层级的对象属性和数组元素。
function deepCopy(obj, visited = new Map()) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    // 遇到了同一个对象，就可以直接返回之前创建的副本，而不会陷入无限递归。
    if (visited.has(obj)) {
        return visited.get(obj);
    }

    const newObj = Array.isArray(obj) ? [] : {};

    visited.set(obj, newObj);

    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            const value = obj[key];
            if (typeof value === 'function') {
                 // 处理函数：创建一个新的函数，确保函数引用不共享
                newObj[key] = function (...args) {
                    return value.apply(newObj, args);
                };
            } else if (value instanceof Date) {
                // 处理日期对象
                newObj[key] = new Date(value);
            } else {
                // 递归拷贝其他属性
                newObj[key] = deepCopy(value, visited);
            }
        }
    }

    return newObj;
}
```

### 防抖 和 节流 分别是什么？
> 防抖: 在一定时间内，如果事件被频繁触发，只执行最后一次事件。可以用于优化一些高频率触发的事件，比如搜索建议等。也就是说当点击一个提交按钮后1s后进行提交，但是如果你在1s内重复点击，那么就从最后一次点击开始计算1s后进行提交。

> 节流：在一定时间间隔内只执行一次函数，用于优化高频率触发的事件，比如 窗口大小改变、滚动事件、鼠标点击事件 等。

与防抖不同的是，节流函数会按照固定的时间间隔执行函数，而不是在等待一段时间后才执行，两者的主要区别在于函数执行的时机和频率。

```js
function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = args
        clearTimeout(fun.id)
        fun.id = setTimeout(function () {
            fun.call(that, _args)
        }, delay)
    }
}


  function throttle(fun, delay) {
        let last, deferTimer
        return function (args) {
            let that = this
            let _args = arguments
            let now = +new Date()
            if (last && now < last + delay) {
                clearTimeout(deferTimer)
                deferTimer = setTimeout(function () {
                    last = now
                    fun.apply(that, _args)
                }, delay)
            }else {
                last = now
                fun.apply(that,_args)
            }
        }
    }
```

### 为什么会产生 闭包？
> [闭包是什么？闭包造成的内存泄漏怎么解决？](https://juejin.cn/post/7109370990248853511?searchId=20240423223653735EE6001462A23620ED)

闭包（closure）是一个函数以及其捆绑的周边环境状态（词法环境）的引用的组合。换句话说，闭包允许开发者从内部函数访问外部函数的作用域，通常就是指 能够访问父作用域的 变量、函数。

广义上来讲，在 JavaScript 中，闭包会随着函数的创建而被同时创建。因为即使一个函数没有访问外部变量，但是它仍然可以捆绑访问到，也就是说 他是有这个资格的，也算是 创建了闭包，只是他没有捆绑外部的引用而已。

为什么说 闭包能够保持外部变量持续存在不会销毁呢？
```js
function foo () {
    var name = 'foo'
    var age = 20

    function bar () {
        console.log(name)
        console.log(age)
    }
    return bar
} // 第二行至第八行为闭包函数 name 和 age 上升为自有变量

var fn = foo()
fn()

```
假设一个闭包函数返回了一个函数，这个函数引用了 父级作用域里的 变量，根据垃圾回收机制，被另一个作用域引用的变量不会被回收。此时，即使 闭包函数执行完毕 了，被销毁了，但是因为 返回的这个函数持续引用了 父级作用域里的变量，所以这个变量不会被回收。

因此，这也造成了，可能存在的 内存泄露风险。

```js
// 避免循环引用：确保闭包不会引用外部函数中的对象，以免导致内存泄漏。
// 及时释放资源：在不再需要闭包时，手动解除对其的引用，以便垃圾回收机制能够回收内存。

fn = null  // 阻止内存泄漏
```

> 优点：

* 避免变量污染：闭包允许我们限制变量的作用范围，避免全局变量的污染。
```js
for(var i = 0; i<10; i++){
  (function(j){
       setTimeout(function(){
        console.log(j)
    }, 1000) 
  })(i)
}

```
* 实现私有方法和属性：通过闭包，我们可以创建私有方法和属性，从而保护代码的隐私性。代码可参考 继承的第三种方法。

* 实现高阶函数，如：防抖函数、节流函数等。

> 缺点：

* 内存占用：闭包会常驻内存，增加内存使用量。不当使用闭包可能导致内存泄漏

### JS 里的 堆 和 栈 有什么区别？分别存储了什么东西，他们两个的优缺点分别是什么，为什么这样设计呢？

> [栈和堆是内存管理中的两个关键概念，它们在存储数据和内存分配方面有着不同的特点。](https://juejin.cn/post/6854573215327617031)
> 栈的特点包括：后进先出、速度快、容量相对较小。堆的特点：速度稍慢、容量比较大。

**栈（Stack）** ：
* 栈是栈内存的简称，它是自动分配相对固定大小的内存空间，并由系统自动释放。
* 栈遵循 **FILO（先进后出）** 的原则，类似于乒乓球盒结构：先放进去的乒乓球只能最后取出来。
* 栈主要用于存放基本数据类型，如Undefined、String、Boolean、Null和Number。这些基本类型的值直接按值存放在栈内存中，占用的内存空间大小是确定的。

**堆（Heap）** ：
* 堆是堆内存的简称，它是动态分配内存，内存大小不固定，也不会自动释放。
* 堆数据结构是一种无序的树状结构，同时满足key-value键值对的存储方式。我们只需知道key名，就能通过key查找到对应的value。
* 堆主要用于存放引用数据类型，如对象（Object）、数组（Array）和函数（Function）。这些引用类型的数据存储于堆中，大小不确定。
* 比较经典的例子是书架存书：我们知道书名，就可以找到对应的书籍。

> 传值和传址的区别：

* * 基本类型采用的是值传递，即将实际的值复制给变量。
引用类型则是地址传递，变量存储的是对象的地址指针，而不是实际的值。当访问引用类型的值时，需要从栈中获取对象的地址指针，然后通过该指针在堆中找到所需的数据。

> 内存分配和垃圾回收：

内存分配：
* 栈内存：线性有序存储，容量小，系统分配效率高。
* 堆内存：首先在堆内存中新分配存储区域，然后将指针存储到栈内存中，效率相对较低。

垃圾回收：
* 栈内存：变量基本上用完就回收，存取速度快，数据可以共享。
* 堆内存：对象不会随方法结束而销毁，只有当没有引用变量指向它时，系统才会回收。

总之，栈和堆在内存管理中扮演着不同的角色，设计如此是为了更好地满足不同类型数据的存储需求。

### Js 如何实现 Module 模块化？

> ES6模块  

ES6（ECMAScript 2015）引入了原生的模块系统，允许在浏览器和Node.js中使用模块。  

使用import和export关键字来定义和导入模块。

> CommonJS

CommonJS是Node.js中使用的模块系统。

使用require和module.exports来导入和导出模块。

> 立即调用的函数表达式（IIFE）

使用IIFE创建闭包，将模块封装在函数作用域内，并提供公共API。
```js
// 在模块文件中
const myModule = (() => {
  const privateVariable = 'Hello, I am private!';

  const publicFunction = () => {
    console.log(privateVariable);
  };

  return {
    publicFunction,
  };
})();

// 在其他文件中使用
myModule.publicFunction();

```

### Js 的变量提升？

> [浅谈 JavaScript 变量提升](https://juejin.cn/post/7007224479218663455)

变量提升是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。

1. 为什么会有变量提升呢？

> JavaScript 和其他语言一样，都要经历编译和执行阶段。在这个短暂的编译阶段，JS 引擎会搜集所有的变量声明，并且提前让声明生效。而剩下的语句需要等到执行阶段、等到执行到具体的某一句时才会生效。这就是变量提升背后的机制。

首先，我们要知道 作用域的定义，它指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，作用域分为两种：

* 全局作用域中的对象在代码中的任何地方都可以访问，其生命周期伴随着页面的生命周期。  
* 函数作用域是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。  

由于没有块级作用域，为了解决这个问题，最初的设计者便将作用域内部的变量统一提升 ，这直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

当然，它也带来了一些额外的优点：
1. 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间；
2. 声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行。

但变量提升机制会导致很多误操作：那些忘记被声明的变量无法在开发阶段被明显地察觉出来，而是以 undefined 的形式藏在代码中。为了减少运行时错误，防止 undefined 带来不可预知的问题，ES6 引入了 let 和 const 关键字，使得 ** 作用块内声明的变量不影响块外面的变量 ** 

```js
	console.log(name);
	let name;
//  输出结果：Uncaught ReferenceError: name is not defined
```

这样在声明之前使用变量就会提示未定义了。

最后 他们还引入了一个 `暂时性死区` 的概念：如果区块中存在 let 和 const，这个区块对这两个关键字声明的变量，从一开始就形成了封闭作用域。假如尝试在声明前去使用这类变量，就会报错。这一段会报错的区域就是暂时性死区。

```js
	name = 'CSS';
	let name;
//  输出结果：Uncaught ReferenceError: Cannot access 'name' before initialization
```

### 说一下 promise？

```
Promise对象有三种状态

Pending（未决）初始状态

Fulfilled（已履行/成功）：操作成功完成时的状态

Rejected（已拒绝/失败）：操作因错误或异常未能完成时的状态

Promise状态变化的特性是：

Promise状态的转变是不可逆且只能发生一次。也就是说，一个Promise不能从Fulfilled状态变回Pending状态，也不能从Rejected状态变为Pending或者Fulfilled状态。 一旦Promise从Pending状态变为Fulfilled（resolved）或Rejected（rejected），它就永远不会再改变。

因此，Promise的状态不能重复改变。
```
> 扩展：

Promise提供了一些额外的函数，比如：

1. Promise.resolve()与Promise.reject() 用于创建已确定状态的Promise对象，方便快速返回成功的或失败的结果

2. Promise.race 关注的是速度最快的 Promise 的结果  - 传入一个 Promise 数组，任何一个 Promise 解决（resolve）或拒绝（reject）时，会立即以那个率先改变状态的 Promise 的结果为准来解决或拒绝。

3. promise对象数组。只有当所有Promise都变为fulfilled时，返回的Promise才会变为fulfilled，并且结果是一个包含所有Promise结果的数组；只要有一个Promise变为rejected，则整体Promise也会立即变为rejected，返回第一个rejected Promise的理由。

4. Promise.allSettled 等待所有Promise都达到settled状态（即无论是fulfilled还是rejected）。一旦所有Promise都决断了，返回的Promise会变成fulfilled，并且结果是一个数组，包含了每个输入Promise的结果描述对象，这些对象具有status（'fulfilled'或'rejected'）和对应的value或reason属性。

> Promise.all() 更关注所有 Promise 是否都成功完成，它适用于需要所有任务成功完成才能继续下一步场景。而 Promise.allSettled() 则允许你观察一组异步操作的所有结果，无论成功与否，这对于获取并处理所有任务的最终状态非常有用。

### == 和 === 的区别？
> == 值相等， ===严格相等，即值和类型都相等

1. === 是 JavaScript 中的严格相等比较操作符，它会同时 比较类型和值。

* 只有在两个操作数具有相同的类型且值相等时，=== 才返回 true。
* 否则，它返回 false。

2. == 是 JavaScript 中的相等比较操作符，它用于比较两个值是否相等。但是，它在进行比较时如果检测到类型不同，会先进行隐式类型转换。

> 显式类型转换是通过一些内置函数（如parseInt()、parseFloat()、String()、Number()等）来显式地进行类型转换。

* 如果两个操作数具有相同的类型，则执行严格相等比较 (===)。
* 如果两个操作数具有不同的类型，则执行类型转换，然后再次执行严格相等比较。

#### 转换规则
> [面试题：为什么[ ] == [ ] 为false, [ ] == ![ ] 为true？](https://juejin.cn/post/7344670957405470759?searchId=2024042322593297EE40ED5BD40538D6B7)


0. NaN不与任何值相等，包括它自己；（所以如果是不相等比较，直接返回 true）
1. 首先比较是否是null和undefined，如果是，则返回true
2. 判断两者是否为字符串与数字的比较，如果是则将字符串转换为数字
3. 判断两者是否为boolean与数字的比较，如果是，则将boolean转换为数字判断
4. 如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都是指向同一个对象，则相等放回true，否则返回false。
5. 如果不是同一对象，则会将Object转换为基本类型，用得到的基本类型值按照前面的规则进行比较
```js
[] === 0
// 1. 先尝试通过调用对象的valueOf()方法来获取原始值。
[].valueOf() ==> []
// 2. 如果valueOf()方法返回的还是一个对象，则会继续调用对象的toString()方法，将其返回值转换为原始值
[].toString() ==> ""
// 比如{} == 0，对于空对象{}它的valueOf() 方法返回的是对象本身，因此 JS 会继续调用 toString() 方法，返回得到一个字符串 "[object Object]"，再转换为数值NaN，所以返回false。

// 3. 此时等式变为 "" == 0，符合第三条
// 4. Number("") ==> 0, 此时等式变为0==0
```

总结：
1. 不同的基本类型比较，都是转换为 数字再进行比较
2. 数组、对象和函数在与其他基本数据类型进行比较时都会先转换为字符串，然后再转换为相应的数据类型。

#### 扩展：Object.is
Object.is 是 ECMAScript 6 中引入的一种比较方法，它旨在提供一种更严格的比较方式，以解决 JavaScript 中一些奇怪的类型比较行为。

* Object.is 通过检查两个值是否相等来进行比较。
* 它遵循与 === 相同的行为，但有两个不同之处：
```js
Object.is(NaN, NaN); // true
NaN === NaN;         // false

Object.is(-0, +0); // false 
-0 === +0; // true
```

### cookie、localStorage、token 的区别？
> [来自本文](https://juejin.cn/post/7344908667039432719#heading-7)

![](https://cdnjson.com/images/2024/04/23/image1440b440da81bf47.png)

### 事件捕获和事件冒泡？
> [来自本文](https://juejin.cn/post/7344908667039432719#heading-24)

