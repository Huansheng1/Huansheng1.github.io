# JavaScript知识点
# 基础
### 宏任务与微任务怎么区分，用精准而简短的话总结下 事件循环？
> [事件循环](https://juejin.cn/post/7337874795684724772#heading-1)


> 消息队列/任务队列：一个先进先出的队列，它里面存放着各种消息。

> 事件循环：主线程重复从消息队列中取消息、执行的过程。

因为JavaScript 是一门单线程语言，这意味着在同一时间内只能执行一项任务。然而，异步任务往往是耗时的，为了在保持单线程的同时避免异步任务阻塞主线程，于是，JavaScript 引入了事件循环机制。

事件循环是JavaScript执行上下文中的一种机制，用于处理异步操作。它的核心思想是将所有的异步任务的回调函数放入一个队列中，然后按照一定的顺序将其压入到 执行栈里执行，直到队列为空为止。主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

异步任务分为 宏任务与微任务：  
宏任务：一类相对低优先级的异步任务，由宿主环境（如浏览器或 Node.js）发起，包括 setTimeout、setInterval、网络请求、IO事件、script的整体代码、UI渲染 等。  
微任务：由 JavaScript 引擎自身发起，包括 Promise的then()、catch（）、finally（）方法、MutationObserver 等。  

整个执行过程可以简要描述为：    
1. 首先，事件循环会查看宏任务（macrotask）队列。如果队列不为空，它会取出队列中的第一个任务并执行。宏任务包括：整个脚本（script），setTimeout，setInterval，setImmediate（Node.js 环境）等。
2. 然后，事件循环会查看微任务（microtask）队列。如果队列不为空，它会连续执行队列中的所有任务，直到队列为空。微任务包括：Promise.then，process.nextTick（Node.js 环境）等。
3. 如果需要的话，浏览器会更新渲染。
4. 重复上述步骤。

[![](https://cdn.jsdelivr.net/gh/Huansheng1/myimg/PicGo/20200720184008.png)](https://www.processon.com/view/link/5f141dfa6376895d7fb8777c)

#### 巩固题
```js
console.log(1);
var a1 = setTimeout(()=>{
    console.log(1.5)
    Promise.resolve(1.6).then(console.log).then(()=>console.log(1.7))
});
Promise.resolve(2).then(console.log).then(()=>console.log(3)).then(()=>console.log(4)).then(()=>console.log(5))
console.log(6)
var a2 = setTimeout(()=>{
    console.log(7);
    Promise.resolve(8).then(console.log).then(()=>console.log(9))
});
Promise.resolve(12).then(console.log)
```
### `Es6`中如何解决 回调地狱的问题？（`Promise`是`Es7`的东西）
> 错的，貌似没这个东西

`Promise 是 ES6（ECMAScript 2015）`

async/await是ES2017引入的语法糖，它基于Promise，但提供了更简洁、更直观的异步编程方式。
使用async/await，你可以写出看起来像是同步代码的异步代码，避免了回调函数的嵌套。

### Js 如何实现继承？
*  原型链继承，将子类的prototype指向父类，子类实例化时，会继承父类的属性和方法。
```js
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
function Child() {  
    this.type = 'child';  
}  
  
Child.prototype = new Parent(); 
// 有一个问题，那就是所有的Child实例都会共享父类的属性，如果其中一个Child实例修改了父类属性，那么其他Child实例的父类属性也会被修改。
```
* 借用构造函数（伪造对象或经典继承）
```js
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
function Child() {  
    Parent.call(this);  
    this.type = 'child';  
}  
  
var child1 = new Child();  
// 可以解决原型链继承中所有Child实例共享父类属性的问题，但是方法都在构造函数中定义，每次创建实例都会创建一遍方法，浪费内存。
```
* 组合继承（原型链 + 借用构造函数），使用原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。
```js
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
Parent.prototype.getName = function() {  
    return this.name;  
}  
  
function Child() {  
    Parent.call(this);  
    this.type = 'child';  
}  
  
Child.prototype = new Parent();  
Child.prototype.constructor = Child;  
  
var child1 = new Child();  
// 融合了原型链继承和借用构造函数的优点，是JavaScript中最常用的继承模式。但是，它也调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）。
```
* 拷贝继承，直接复制父类型的属性到子类型中。
```js
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
function Child() {  
    var p = new Parent();  
    for (var i in p) {  
        this[i] = p[i];  
    }  
    this.type = 'child';  
}  
  
var child1 = new Child();  
```
* ES6中的类继承，直接使用 extends 关键字 继承父类。
```js
class Parent {  
    constructor() {  
        this.name = 'parent';  
    }  
    getName() {  
        return this.name;  
    }  
}  
  
class Child extends Parent {  
    constructor() {  
        super();  
        this.type = 'child';  
    }  
}  
  
let child1 = new Child();  
// 既解决了原型链继承的共享问题，又解决了借用构造函数的复用问题，是ES6推荐的继承方式。
```

### Js 的数据类型有哪些？
![](https://cdnjson.com/images/2024/04/23/image85611b9f987c0206.png)
![](https://cdnjson.com/images/2024/04/23/image6636bbbadd40a360.png)

### 想检测一个复杂数据的类型，应该怎么检测？
对象类型 使用 `Object.prototype.toString.call()`
基本数据类型 使用 `typeof`

### 深拷贝 和 浅拷贝的区别？
> 区别在于是否复制了嵌套对象的引用。在JS理，基本数据类型的值直接存储在栈中，而引用数据类型在栈中的值存储的是该对象数据的引用，真实的数据存放在堆内存里。  

> 浅拷贝：

浅拷贝只复制指向某个对象的指针，而不复制对象本身。  
新旧对象仍然共享同一块内存。  
浅拷贝只复制一层，不会递归拷贝嵌套对象的属性。  
常见的浅拷贝方法包括 Object.assign()、Array.prototype.concat() 和 Array.prototype.slice()。  

> 深拷贝：

深拷贝创建一个原始数据结构及其所有嵌套对象的完整副本。  
新对象跟原对象不共享内存，修改新对象不会影响到原对象。  
深拷贝会递归拷贝所有层级的对象属性和数组元素。  
常见的深拷贝方法包括手写递归方法、JSON.parse(JSON.stringify()) 和第三方库如 Lodash 的 _.cloneDeep。  

```js
// 1. 使用 JSON.parse(JSON.stringify(obj)) 实现，但是有一些特殊的类型无法拷贝，如函数、正则、循环递归等。
// 2. 手写递归实现，递归拷贝所有层级的对象属性和数组元素。
function deepCopy(obj, visited = new Map()) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    // 遇到了同一个对象，就可以直接返回之前创建的副本，而不会陷入无限递归。
    if (visited.has(obj)) {
        return visited.get(obj);
    }

    const newObj = Array.isArray(obj) ? [] : {};

    visited.set(obj, newObj);

    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            const value = obj[key];
            if (typeof value === 'function') {
                 // 处理函数：创建一个新的函数，确保函数引用不共享
                newObj[key] = function (...args) {
                    return value.apply(newObj, args);
                };
            } else if (value instanceof Date) {
                // 处理日期对象
                newObj[key] = new Date(value);
            } else {
                // 递归拷贝其他属性
                newObj[key] = deepCopy(value, visited);
            }
        }
    }

    return newObj;
}
```

### 防抖 和 节流 分别是什么？
> 防抖: 在一定时间内，如果事件被频繁触发，只执行最后一次事件。可以用于优化一些高频率触发的事件，比如搜索建议等。也就是说当点击一个提交按钮后1s后进行提交，但是如果你在1s内重复点击，那么就从最后一次点击开始计算1s后进行提交。

> 节流：在一定时间间隔内只执行一次函数，用于优化高频率触发的事件，比如 窗口大小改变、滚动事件、鼠标点击事件 等。

与防抖不同的是，节流函数会按照固定的时间间隔执行函数，而不是在等待一段时间后才执行，两者的主要区别在于函数执行的时机和频率。

```js
function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = arguments
        if(fun.id){
            clearTimeout(fun.id)
        }else{
        fun.id = setTimeout(function () {
            // function.call(thisArg, arg1, arg2, ...)
            fun.call(that, ..._args)
        }, delay)
        }
    }
}

// 为什么节流用的是时间戳，而不是定时器，是因为定时器因为事循环的原因，并不一定完全是设置的delay，而new Date()更精确
function throttle(fun, delay) {
      let pretime 
      return function (args) {
        let that = this
        let _args = arguments
        let now = Date.now()
        if (pretime  && now >= pretime  + delay) {
            pretime  = now
            // function.apply(thisArg, [argsArray])
            fun.apply(that,_args)
            // 如果是 bind
            // fun.bind(that,..._args)()
        }
    }
}
```

### 为什么会产生 闭包？
> [闭包是什么？闭包造成的内存泄漏怎么解决？](https://juejin.cn/post/7109370990248853511?searchId=20240423223653735EE6001462A23620ED)

闭包（closure）是一个函数以及其捆绑的周边环境状态（词法环境）的引用的组合。换句话说，闭包允许开发者从内部函数访问外部函数的作用域，通常就是指 能够访问父作用域的 变量、函数。

广义上来讲，在 JavaScript 中，闭包会随着函数的创建而被同时创建。因为即使一个函数没有访问外部变量，但是它仍然可以捆绑访问到，也就是说 他是有这个资格的，也算是 创建了闭包，因为有全局环境，所有的函数都可以访问全局变量。

为什么说 闭包能够保持外部变量持续存在不会销毁呢？
```js
function foo () {
    var name = 'foo'
    var age = 20

    function bar () {
        console.log(name)
        console.log(age)
    }
    return bar
} // 第二行至第八行为闭包函数 name 和 age 上升为自有变量

var fn = foo()
fn()

```
假设一个闭包函数返回了一个函数，这个函数引用了 父级作用域里的 变量，根据垃圾回收机制，被另一个作用域引用的变量不会被回收。此时，即使 闭包函数执行完毕 了，被销毁了，但是因为 返回的这个函数持续引用了 父级作用域里的变量，所以这个变量不会被回收。

因此，这也造成了，可能存在的 内存泄露风险。

```js
// 避免循环引用：确保闭包不会引用外部函数中的对象，以免导致内存泄漏。
// 及时释放资源：在不再需要闭包时，手动解除对其的引用，以便垃圾回收机制能够回收内存。

fn = null  // 阻止内存泄漏
```

> 优点：

* 避免变量污染：闭包允许我们限制变量的作用范围，避免全局变量的污染。
```js
for(var i = 0; i<10; i++){
  (function(j){
       setTimeout(function(){
        console.log(j)
    }, 1000) 
  })(i)
}

```
* 实现私有方法和属性：通过闭包，我们可以创建私有方法和属性，从而保护代码的隐私性。代码可参考 继承的第三种方法。

* 实现高阶函数，如：防抖函数、节流函数等。

> 缺点：

* 内存占用：闭包会常驻内存，增加内存使用量。不当使用闭包可能导致内存泄漏

### JS 里的 堆 和 栈 有什么区别？分别存储了什么东西，他们两个的优缺点分别是什么，为什么这样设计呢？

> [栈和堆是内存管理中的两个关键概念，它们在存储数据和内存分配方面有着不同的特点。](https://juejin.cn/post/6854573215327617031)
> 栈的特点包括：后进先出、速度快、容量相对较小。堆的特点：速度稍慢、容量比较大。

**栈（Stack）** ：
* 栈是栈内存的简称，它是自动分配相对固定大小的内存空间，并由系统自动释放。
* 栈遵循 **FILO（先进后出）** 的原则，类似于乒乓球盒结构：先放进去的乒乓球只能最后取出来。
* 栈主要用于存放基本数据类型，如Undefined、String、Boolean、Null和Number。这些基本类型的值直接按值存放在栈内存中，占用的内存空间大小是确定的。

**堆（Heap）** ：
* 堆是堆内存的简称，它是动态分配内存，内存大小不固定，也不会自动释放。
* 堆数据结构是一种无序的树状结构，同时满足key-value键值对的存储方式。我们只需知道key名，就能通过key查找到对应的value。
* 堆主要用于存放引用数据类型，如对象（Object）、数组（Array）和函数（Function）。这些引用类型的数据存储于堆中，大小不确定。
* 比较经典的例子是书架存书：我们知道书名，就可以找到对应的书籍。

> 传值和传址的区别：

* * 基本类型采用的是值传递，即将实际的值复制给变量。
引用类型则是地址传递，变量存储的是对象的地址指针，而不是实际的值。当访问引用类型的值时，需要从栈中获取对象的地址指针，然后通过该指针在堆中找到所需的数据。

> 内存分配和垃圾回收：

内存分配：
* 栈内存：线性有序存储，容量小，系统分配效率高。
* 堆内存：首先在堆内存中新分配存储区域，然后将指针存储到栈内存中，效率相对较低。

垃圾回收：
* 栈内存：变量基本上用完就回收，存取速度快，数据可以共享。
* 堆内存：对象不会随方法结束而销毁，只有当没有引用变量指向它时，系统才会回收。

总之，栈和堆在内存管理中扮演着不同的角色，设计如此是为了更好地满足不同类型数据的存储需求。

### Js 如何实现 Module 模块化？

> ES6模块  

ES6（ECMAScript 2015）引入了原生的模块系统，允许在浏览器和Node.js中使用模块。  

使用import和export关键字来定义和导入模块。

> CommonJS

CommonJS是Node.js中使用的模块系统。

使用require和module.exports来导入和导出模块。

> 立即调用的函数表达式（IIFE）

使用IIFE创建闭包，将模块封装在函数作用域内，并提供公共API。
```js
// 在模块文件中
const myModule = (() => {
  const privateVariable = 'Hello, I am private!';

  const publicFunction = () => {
    console.log(privateVariable);
  };

  return {
    publicFunction,
  };
})();

// 在其他文件中使用
myModule.publicFunction();

```

### Js 的变量提升？

> [浅谈 JavaScript 变量提升](https://juejin.cn/post/7007224479218663455)

变量提升是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。

1. 为什么会有变量提升呢？

> JavaScript 和其他语言一样，都要经历编译和执行阶段。在这个短暂的编译阶段，JS 引擎会搜集所有的变量声明，并且提前让声明生效。而剩下的语句需要等到执行阶段、等到执行到具体的某一句时才会生效。这就是变量提升背后的机制。

首先，我们要知道 作用域的定义，它指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，作用域分为两种：

* 全局作用域中的对象在代码中的任何地方都可以访问，其生命周期伴随着页面的生命周期。  
* 函数作用域是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。  

由于没有块级作用域，为了解决这个问题，最初的设计者便将作用域内部的变量统一提升 ，这直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

当然，它也带来了一些额外的优点：
1. 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间；
2. 声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行。

但变量提升机制会导致很多误操作：那些忘记被声明的变量无法在开发阶段被明显地察觉出来，而是以 undefined 的形式藏在代码中。为了减少运行时错误，防止 undefined 带来不可预知的问题，ES6 引入了 let 和 const 关键字，使得 ** 作用块内声明的变量不影响块外面的变量 ** 

```js
	console.log(name);
	let name;
//  输出结果：Uncaught ReferenceError: name is not defined
```

这样在声明之前使用变量就会提示未定义了。

最后 他们还引入了一个 `暂时性死区` 的概念：如果区块中存在 let 和 const，这个区块对这两个关键字声明的变量，从一开始就形成了封闭作用域。假如尝试在声明前去使用这类变量，就会报错。这一段会报错的区域就是暂时性死区。

```js
	name = 'CSS';
	let name;
//  输出结果：Uncaught ReferenceError: Cannot access 'name' before initialization
```

### 说一下 promise？

```
Promise对象有三种状态

Pending（未决）初始状态

Fulfilled（已履行/成功）：操作成功完成时的状态

Rejected（已拒绝/失败）：操作因错误或异常未能完成时的状态

Promise状态变化的特性是：

Promise状态的转变是不可逆且只能发生一次。也就是说，一个Promise不能从Fulfilled状态变回Pending状态，也不能从Rejected状态变为Pending或者Fulfilled状态。 一旦Promise从Pending状态变为Fulfilled（resolved）或Rejected（rejected），它就永远不会再改变。

因此，Promise的状态不能重复改变。
```
> 扩展：

Promise提供了一些额外的函数，比如：

1. Promise.resolve()与Promise.reject() 用于创建已确定状态的Promise对象，方便快速返回成功的或失败的结果

2. Promise.race 关注的是速度最快的 Promise 的结果  - 传入一个 Promise 数组，任何一个 Promise 解决（resolve）或拒绝（reject）时，会立即以那个率先改变状态的 Promise 的结果为准来解决或拒绝。

3. promise对象数组。只有当所有Promise都变为fulfilled时，返回的Promise才会变为fulfilled，并且结果是一个包含所有Promise结果的数组；只要有一个Promise变为rejected，则整体Promise也会立即变为rejected，返回第一个rejected Promise的理由。

4. Promise.allSettled 等待所有Promise都达到settled状态（即无论是fulfilled还是rejected）。一旦所有Promise都决断了，返回的Promise会变成fulfilled，并且结果是一个数组，包含了每个输入Promise的结果描述对象，这些对象具有status（'fulfilled'或'rejected'）和对应的value或reason属性。

> Promise.all() 更关注所有 Promise 是否都成功完成，它适用于需要所有任务成功完成才能继续下一步场景。而 Promise.allSettled() 则允许你观察一组异步操作的所有结果，无论成功与否，这对于获取并处理所有任务的最终状态非常有用。

### == 和 === 的区别？
> == 值相等， ===严格相等，即值和类型都相等

1. === 是 JavaScript 中的严格相等比较操作符，它会同时 比较类型和值。

* 只有在两个操作数具有相同的类型且值相等时，=== 才返回 true。
* 否则，它返回 false。

2. == 是 JavaScript 中的相等比较操作符，它用于比较两个值是否相等。但是，它在进行比较时如果检测到类型不同，会先进行隐式类型转换。

> 显式类型转换是通过一些内置函数（如parseInt()、parseFloat()、String()、Number()等）来显式地进行类型转换。

* 如果两个操作数具有相同的类型，则执行严格相等比较 (===)。
* 如果两个操作数具有不同的类型，则执行类型转换，然后再次执行严格相等比较。

#### 转换规则
> [面试题：为什么[ ] == [ ] 为false, [ ] == ![ ] 为true？](https://juejin.cn/post/7344670957405470759?searchId=2024042322593297EE40ED5BD40538D6B7)


0. NaN不与任何值相等，包括它自己；（所以如果是不相等比较，直接返回 true）
1. 首先比较是否是null和undefined，如果是，则返回true
2. 判断两者是否为字符串与数字的比较，如果是则将字符串转换为数字
3. 判断两者是否为boolean与数字的比较，如果是，则将boolean转换为数字判断
4. 如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都是指向同一个对象，则相等放回true，否则返回false。
5. 如果不是同一对象，则会将Object转换为基本类型，用得到的基本类型值按照前面的规则进行比较
```js
[] === 0
// 1. 先尝试通过调用对象的valueOf()方法来获取原始值。
[].valueOf() ==> []
// 2. 如果valueOf()方法返回的还是一个对象，则会继续调用对象的toString()方法，将其返回值转换为原始值
[].toString() ==> ""
// 比如{} == 0，对于空对象{}它的valueOf() 方法返回的是对象本身，因此 JS 会继续调用 toString() 方法，返回得到一个字符串 "[object Object]"，再转换为数值NaN，所以返回false。

// 3. 此时等式变为 "" == 0，符合第三条
// 4. Number("") ==> 0, 此时等式变为0==0
```

总结：
1. 不同的基本类型比较，都是转换为 数字再进行比较
2. 数组、对象和函数在与其他基本数据类型进行比较时都会先转换为字符串，然后再转换为相应的数据类型。

#### 扩展：Object.is
Object.is 是 ECMAScript 6 中引入的一种比较方法，它旨在提供一种更严格的比较方式，以解决 JavaScript 中一些奇怪的类型比较行为。

* Object.is 通过检查两个值是否相等来进行比较。
* 它遵循与 === 相同的行为，但有两个不同之处：
```js
Object.is(NaN, NaN); // true
NaN === NaN;         // false

Object.is(-0, +0); // false 
-0 === +0; // true
```

### cookie、localStorage、token 的区别？
> [来自本文](https://juejin.cn/post/7344908667039432719#heading-7)

![](https://cdnjson.com/images/2024/04/23/image1440b440da81bf47.png)

### 事件捕获和事件冒泡？
> [来自本文](https://juejin.cn/post/7344908667039432719#heading-24)

### 原型，class B 继承 class A 翻译成 es5 应该是什么样子
> [参考](https://juejin.im/post/5c433e216fb9a049c15f841b)

### import 和 require 导入的区别
> [前端模块化：CommonJS,AMD,CMD,ES6](https://juejin.cn/post/6844903576309858318)

高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。 2.前者编译时输出接口，后者运行时加载。

#### require 有什么性能问题
因为它是值的拷贝，且 运行时加载，因此性能更差

### 组件库如何做按需加载
> babel-plugin-import

### webpack 如何实现动态加载
讲道理 webpack 动态加载就两种方式：import()和 require.ensure，不过他们实现原理是相同的。

我觉得这道题的重点在于动态的创建 script 标签，以及通过 jsonp 去请求 chunk，推荐的文章是：[webpack是如何实现动态导入的](https://juejin.cn/post/6844903888319954952)


### require 引入的模块 webpack 能做 Tree Shaking 吗？
> 不能，Tree Shaking 需要静态分析，只有 ES6 的模块才支持。

### 箭头函数和普通函数区别
> [2022年了你还不了解箭头函数与普通函数的区别吗？](https://juejin.cn/post/7069943937577779214?searchId=20240426171342C27ABA094F90848D1358)

箭头函数 不使用 function 关键字声明，不能当成一个构造函数，不能直接设置名字，没有 原型prototype、arguments关键字，`它没有自己的this对象，内部的this就是定义时上层作用域中的this`。也就是说，箭头函数内部的this指向是固定的，`不能使用 call、apply、bind 修改 this指向`。

对于普通函数来说，内部的this指向函数运行时所在的对象，注意，是运行时，而不是声明定义的时候。
#### 箭头函数能使用 call、bind、apply修改 this指向吗？
不能
### 除了闭包有没有别的方法来实现私有属性？
使用`defineProperty`来实现，设置 enumerable 可枚举属性 为 false 即可：
```js
Object.defineProperty(this, 'getPrivateProperty', {
        value: function() {
            return privateProperty;
        },
        enumerable: false
    });
```

#### 了解 严格模式的JS吗？他里面的var有什么特殊之处？
> [Javascript 严格模式详解](https://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)

1. **全局变量必须显式声明**：在严格模式下，如果一个变量没有声明就赋值，默认是全局变量，这种用法会导致错误123。因此，严格模式下，变量都必须先用var命令声明，然后再使用。
```js
"use strict";
v = 1; // 报错，v未声明
for(i = 0; i < 2; i++) { // 报错，i未声明
}
```
2. **禁止删除变量**：严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。
3. **禁止变量重名**：严格模式要求函数的参数名唯一。在正常模式下，最后一个重名参数名会掩盖之前的重名参数。之前的参数仍然可以通过arguments[i]来访问, 还不是完全无法访问。然而，这种隐藏毫无意义而且可能是意料之外的 (比如它可能本来是打错了), 所以在严格模式下重名参数被认为是语法错误。
4. **静态绑定**：严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。
5. 禁止this关键字指向全局对象
6. **显式报错**：比如：对一个对象的只读属性进行赋值，将报错。
7. **保留字**：为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。


### sessionStorage 能在多个标签页之间共享数据吗？
> [面试官：sessionStorage 能在多个标签页之间共享数据吗？](https://juejin.cn/post/7362080157190570010)
不能，因为sessionStorage 是属于当前页面的会话级存储，每一个标签页是不同的会话，与 localstorage 是不一样的。

> MDN 的解释：
* 在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookie 的运行方式不同。
* 打开多个相同的 URL 的 Tabs 页面，会创建各自的 sessionStorage。

### 函数式编程的副作用是什么

### quill编辑器的原理是什么？

### 不用promise怎么解决回调地狱的问题？
> 如 NodeJs 里的 EventEmitter事件监听 方式

### websocket了解吗？
> [WebSocket 从入门到入土](https://juejin.cn/post/7309687967063818292?searchId=20240428190120ECC0F3994E05761D7F2E#heading-11)

## 好文推荐
* [拼多多和酷家乐面试经历总结](https://juejin.cn/post/6844904151013392398)
* [蚂蚁、字节、滴滴面试经历总结](https://juejin.cn/post/6844904161830502407)