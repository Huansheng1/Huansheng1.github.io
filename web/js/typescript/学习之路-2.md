# 学习之路-2
## tsconfig
1. 生成tsconfig.json配置文件：`tsc --init`
2. 修改当前命令所在目录下的 tsconfig.json配置文件
## TypeScript 类型
* TypeScript的类型检测是通过 鸭子类型检测，只要 属性和行为（方法）相同，就可以通过编译。

## 联合类型
> TypeScript的类型系统允许我们**使用 `|`（管道）符号使用现有类型中构建新类型**。

联合类型（Union Types）表示取值可以为**多种类型中的一种**，每一个成员叫做联合成员

```ts
function getOrderDetail(orderId: string | number){
    return axios.get(`/order/${orderId}`);
}

getOrderDetail('123');
getOrderDetail(123);
```
## 类型别名
```ts
// IdType 这个就是类型别名
type IdType = string | number;
function getOrderDetail(orderId: IdType){
    return axios.get(`/order/${orderId}`);
}
```
## 交叉类型
> **使用 `&`（与）符号**

交叉类型（Intersection Types）表示取值为同时满足多种类型的值。

```ts
interface IKun {
    name: string,
    age: number,
    slogan: string
}
interface ICoder {
    name: string,
    skill: string,
    coding: () => void
}
// ted 是一个 程序员，也是个 小黑子
const ted: IKun & ICoder = {
    name: 'ted',
    age: 18,
    slogan: '你干嘛~',
    skill: 'Angular、Vue、微信小程序、TypeScript',
    coding: function () {
        console.log(`${this.name} is coding`);
    }
}
ted.coding();
```
## 类型断言as
> 类型断言（Type Assertion）可以用来手动指定一个值的类型。

TypeScript类型断言允许 手动指定为 更具体（类型缩小）的类型 或者 不太明确的类型（主要指 `any` 或者 `unknown` 类型）。
```ts
const imageEl = document.querySelector('.img') as HTMLImageElement; // 默认是 Element | null，这样的话，没法访问到 imageEl.src
imageEl.src = 'https://picsum.photos/200/300';

let IdStr = "123";
// 类型 "number" 到类型 "string" 的转换可能是错误的，因为两种类型不能充分重叠。如果这是有意的，请先将表达式转换为 "unknown"。ts(2352)
// Ts是不允许断言从一个具体的类型断言到到另一个类型，除非是包含关系
// IdStr = 123 as string;

// 但是允许通过 不具体的any或者unknown 来间接转换
IdStr = (123 as any) as string;
```
### 非空类型断言
> 非空断言（Non-null assertion）允许我们明确知道一个值不为空，所以可以忽略编译器对空值的检查。

```ts
interface Person {
    name: string,
    friend?: {
        name: string
    }
}

const jack: Person = { name: 'jack' };
// 一般如果取某个值的话，我们会使用 可选链式符号 ?.
// console.log(jack.friend?.name);
// 但是，如果是赋值的话，我们是没法直接使用 ?. 的，如果你确定一定存在值的话，可以使用 !. 但是是有点危险的
jack.friend!.name = 'tom'; // 示范的这个地方其实是不该这么做的
```
## 字面量类型
> 字面量类型（Literal Types）允许我们使用字面量来表示类型。（其实属于字符串，是字符串的更小的子集，表示一个具体的字符串值）

一般情况下，意义不大，但是作为联合类型，搭配使用就比较常见了：
```ts
type Direction = 'up' | 'down' | 'left' | 'right';
let direction: Direction = 'up';
// 不能将类型“"test"”分配给类型“Direction”。ts(2322)
// direction = 'test';

const axios = require('axios');
function request(url: string, method: 'GET' | 'POST') {
    return axios(url, method);
}
// 1. 限制调用处传参
request('https://baidu.com', 'GET');

// 注意的一个点：如果参数是先定义了再使用的话，自动推导是推导为一个 string字符串的，这会导致无法通过字面量的校验
// const requestOptions = {
//     url: 'https://baidu.com',
//     method: 'GET',
// };
// 类型“string”的参数不能赋给类型“"GET" | "POST"”的参数。ts(2345)
// request(requestOptions.url, requestOptions.method);

// 解决方法1：类型断言
const requestOptions = {
    url: 'https://baidu.com',
    method: 'GET' as 'GET',
};
request(requestOptions.url, requestOptions.method);
// request(requestOptions.url, requestOptions.method as 'GET');

// 解决方法2：使用 ts 提供的一个 as const 语法，可以自动推导为其值为 readonly+字面量 类型
const requestOptions2 = {
    url: 'https://baidu.com',
    method: 'GET',
} as const;
request(requestOptions.url, requestOptions2.method);
```
## 函数类型
TypeScript中，函数也是类型，函数类型由参数类型和返回值类型组成。

函数类型声明有两种方式：
### 函数类型表达式
格式为：`(参数: 参数类型) => 返回值类型`

需要注意，其不会校验函数的个数：
```ts
// 定义操作函数类型
type Operation = (a: number, b: number) => number;

// 定义计算器接口
interface Calculator {
    calculate(a: number, b: number, operation: Operation): number;
}

// 实现计算器类
class BasicCalculator implements Calculator {
    calculate(a: number, b: number, operation: Operation): number {
        return operation(a, b);
    }
}

// 定义加法、减法、乘法和除法操作函数
const add: Operation = (a, b) => a + b;
const subtract: Operation = (a, b) => a - b;
const multiply: Operation = (a, b) => a * b;
const divide: Operation = (a, b) => a / b;

// 示例使用
const calculator = new BasicCalculator();
console.log(calculator.calculate(5, 3, add));       // 输出: 8
console.log(calculator.calculate(10, 2, subtract));  // 输出: 8
console.log(calculator.calculate(4, 6, multiply));  // 输出: 24
console.log(calculator.calculate(15, 3, divide));   // 输出: 5
// 即使没满足必须是 2个参数，但是Ts也不会报错，需要注意
// const test: Operation = (a) => a;
// calculator.calculate(5, 3, test)
// 原因是：Ts在类型检测和好用之间的平衡，所以不报错
// 如果不同就报错的话：
// 那么我们使用一些内置的函数，比如 array.forEach之类的函数，也每次必须传递三个参数了，不然就会报错
```
### 函数调用签名
> 在 JavaScript 中，函数是一等公民，函数也是个对象，可以有其他属性，而上面的方式是没法定义函数的其他属性的

```ts
interface SearchFunc {
    // 支持声明其他属性
    desc?: string;
    toString?: () => string;
    // 声明函数调用方式：使用 (参数：参数类型) : 返回值类型;
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc = function (source: string, subString: string) {
    let result = source.search(subString);
    return result > -1;
};
mySearch.desc = '能够搜索判断一个字符串是否存在某个字符串的工具函数';
mySearch.toString = () => {
    return '一个搜索字符串的函数';
}
// true 能够搜索判断一个字符串是否存在某个字符串的工具函数 一个搜索字符串的函数
console.log(mySearch('123456', '23'), mySearch.desc, mySearch.toString());
```
### 总结
开发中如何选择:

1. 如果只是描述函数类型本身(函数可以被调用)，使用 函数类型表达式(`Function Type Expressions`)
2. 如果在描述函数作为对象可以被调用，同时也有其他属性时， 使用 函数调用签名(`Call Signatures`)

### 构造函数签名
用的较少，主要用于工具库，平时其实用 `class`更常见点。

```ts
// 定义了一个 函数构造签名，表示通过该函数 new 的对象是 Person 类型，如果不这样定义的话，自动推导只能给出个 any 类型
interface ConstructorSignature {
    new(name: string, age: number): Person;
}

// 定义Person接口，描述实例的属性和方法
interface Person {
    name: string;
    age: number;
    sayHello(): void;
}

// 使用函数构造签名创建类
function createPerson(constructorSignature: ConstructorSignature): Person {
    return new constructorSignature("Alice", 30);
}
```
### 函数重载签名
在实际开发中，有时候，同一个函数可能根据传入的参数类型有不同的实现。通过联合签名是没法实现的，比如以下代码：
```ts
function add(a: string|number, b: string|number): string|number{
  return a + b;
}
add(1,'222'); // 这样不是我们想要的结果，我们只想要 数字+数字，字符串+字符串
```
为了解决类型与类型的对应问题，数字与数字相加，字符串与字符串相加，不相等就不想加，我们可以采取以下的方式：
```ts
// 定义第一个重载，用于添加两个数字
function add(a: number, b: number): number
// 定义第二个重载，用于连接两个字符串
function add(a: string, b: string): string
// 编写一个实际的函数实现
function add(a: any, b: any): string | number {
    return a + b;
}

// 使用函数重载的例子
console.log(add(1, 2)); // 输出：3
console.log(add("Hello ", "World")); // 输出：Hello World
// 针对此实现的调用已成功，但重载的实现签名在外部不可见。
// add(1,'222')
```
### 提取函数类型
通过 typeof 可以快速获取已定义的函数类型
```ts
function foo() {
    console.log("foo");
    return 'foo method!';
}
type FooMethod = typeof foo;
```
## This内置工具函数
> 一般用于封装工具库 或者 框架
### ThisParameterType
### PureThisType
### ThisType
### ReturnType
## class类与关键字
类 可以当做构造签名函数来使用：
```ts
class Person {
    constructor(public name: string, public age: number) { }
}
function factory(cons: new (...args: any[]) => void) {
    return new cons();
}
// 这样是不会报错的~
factory(Person);
```
### public、private、protected
在TypeScript中,类的属性和方法支持3种修饰符: `public`、 `private`、 `protected`：

* `public`修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是public的; 默认的修饰符。
* `private`修饰的是仅在同一类中可见、私有的属性或方法;
* `protected`修饰的是仅在类自身及子类中可见、受保护的属性或方法;

```ts
class MyClass {
    // public 成员：在类的任何地方以及类的实例上都可以访问
    public publicVar = "Public variable";
    public publicMethod() {
        console.log("Public method called.");
        return "Public method!";
    }

    // private 成员：只能在类的内部访问，不能在类的实例上访问
    private privateVar = "Private variable";
    private privateMethod() {
        console.log("Private method called.");
        return "Private method!";
    }

    // protected 成员：在类的内部和子类中可以访问，但在类的实例上不能直接访问
    protected protectedVar = "Protected variable";
    protected protectedMethod() {
        console.log("Protected method called.");
        return "Protected method!";
    }
}

// 创建类的实例
const instance = new MyClass();

// 访问 public 成员
console.log(instance.publicVar); // 输出：Public variable
console.log(instance.publicMethod()); // 输出：Public method!

// 尝试访问 private 成员（会抛出错误）
// console.log(instance.privateVar); // 编译错误 - 属性“privateVar”为私有属性，只能在类“MyClass”中访问。ts(2341)
// console.log(instance.privateMethod()); // 编译错误 - 属性“privateMethod”为私有属性，只能在类“MyClass”中访问。ts(2341)

// 尝试访问 protected 成员（会抛出错误）
// console.log(instance.protectedVar); // 编译错误 - 属性“protectedVar”受保护，只能在类“MyClass”及其子类中访问。ts(2445)
// console.log(instance.protectedMethod()); // 编译错误

// 创建子类
class MySubClass extends MyClass {
    constructor() {
        super();
    }

    // 子类中可以访问 protected 成员
    useProtected() {
        console.log(this.protectedVar); // 输出：Protected variable
        console.log(this.protectedMethod()); // 输出：Protected method!
    }
}

// 创建子类实例并访问 protected 成员
const subInstance = new MySubClass();
subInstance.useProtected();
```
#### 参数属性 语法糖
TypeScript提供了一种语法糖，允许在构造函数的参数定义时直接初始化类的成员，不需要单独为类成员编写初始化语句。
```ts
// 如果不使用参数属性的话，是这样子的：
// class Person {
//     public name: string;
//     private age: number;
//     constructor(name: string, age: number) {
//         this.name = name;
//         this.age = age;
//     }

//     // 显示个人信息的方法
//     displayInfo() {
//         console.log(`Name: ${this.name}, Age: ${this.age}`);
//     }
// }

class Person {
    // 使用参数属性定义和初始化name和age成员
    constructor(public name: string, private age: number) {
        // 注意：这里不需要再有单独的this.name = name; 和 this.age = age; 语句
    }

    // 显示个人信息的方法
    displayInfo() {
        console.log(`Name: ${this.name}, Age: ${this.age}`);
    }
}

// 创建Person类的实例
const person = new Person("Alice", 30);

// 调用displayInfo方法输出信息
person.displayInfo();
```

### setter、getter
这两个一般搭配 私有属性使用，用来控制属性的读写权限。
```ts
class User {
    // 声明一个私有变量，只能在类的内部访问
    private _email: string;

    // 使用getter公开私有变量的读取访问
    get email(): string {
        // 可以在这里添加逻辑，例如验证或处理数据
        return this._email;
    }

    // 使用setter公开私有变量的写入访问，并允许添加额外的逻辑
    set email(value: string) {
        // 模拟一个简单的邮箱格式验证
        if (/^\S+@\S+\.\S+$/.test(value)) {
            this._email = value;
        } else {
            throw new Error('Invalid email format.');
        }
    }
}

// 创建User类的实例
const user = new User();

try {
    // 尝试设置一个有效的邮箱
    user.email = 'example@example.com';
    console.log(`Email set to: ${user.email}`); // 正确输出邮箱

    // 尝试设置一个无效的邮箱，这将抛出错误
    user.email = 'not-an-email';
} catch (error) {
    console.error(error.message); // 输出错误信息
}
```
## 抽象类
抽象类是专门用来被继承的类，它不能被实例化。抽象类可以包含抽象方法和抽象属性。抽象方法必须被实现，否则会报错，并且必须在抽象类中。

```ts
// 定义一个抽象类Animal
abstract class Animal {
    // 抽象方法makeSound没有具体实现
    abstract makeSound(): void;
}

// Dog类继承Animal类
class Dog extends Animal {
    // 实现抽象方法makeSound
    makeSound() {
        console.log("汪汪汪");
    }
}

// Cat类也继承Animal类
class Cat extends Animal {
    // 实现抽象方法makeSound
    makeSound() {
        console.log("喵喵喵");
    }
}

// 通过声明为 父类，可以便于声明通用的方法，而不是通过联合类型，新增时需要添加新的子类
// 其实就是 Java 里的多态：多态是面向对象编程中的一个重要概念，它允许我们定义一个父类，然后创建多个子类，这些子类可以有不同的实现，但是共享相同的父类。
function animalSound(animal: Animal) {
    // 调用动物的叫声方法
    animal.makeSound();
}

// 创建Dog和Cat的实例
const myDog = new Dog();
const myCat = new Cat();

// 通过同一个函数调用不同对象的makeSound方法，展示多态性
animalSound(myDog); // 输出: 汪汪汪
animalSound(myCat); // 输出: 喵喵喵
```
## 索引签名
索引签名允许我们定义一个对象类型，该对象可以包含任意数量的属性，并且这些属性的类型都是相同的。
```ts
// 定义一个具有字符串索引签名的对象类型，表示一个存储名字的字典
interface NameDictionary {
    [key: string]: string;
}

// 创建一个符合NameDictionary类型的对象实例
const names: NameDictionary = {
    john: 'John Doe',
    jane: 'Jane Smith',
};

// 动态添加属性，TypeScript允许这样做，因为符合索引签名定义
names['joe'] = 'Joe Bloggs';

// 尝试添加一个非字符串类型的键，TypeScript会报错
// names[1] = 'Invalid'; // 错误：不能用数字作为NameDictionary的键

// 访问对象的属性
console.log(names['john']); // 输出：John Doe
console.log(names['jane']); // 输出：Jane Smith
console.log(names['joe']);  // 输出：Joe Bloggs
```
## 接口类型
接口类型是一种特殊的类型，它定义了一组属性和函数签名。它允许我们定义一个对象类型，该对象必须具有特定的属性和函数签名。
```ts
interface Person {
    name: string;
    age: number;
}
// 接口可以继承另一个接口，关键词是 extends
interface Employee extends Person {
    salary: number;
}
let person: Employee = {
    name: "John",
    age: 30,
    salary: 50000
};
// 接口可以被类实现，注意，实现的关键字是 implements
class Developer implements Employee {
    name: string;
    age: number;
    salary: number;
}
let dev: Developer = new Developer();
```
## 更多
> 211 类型-修饰符-抽象类-接口类型-字面量赋值 2:13:18